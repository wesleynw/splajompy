// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	db "splajompy.com/api/v2/internal/db"
)

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts
WHERE post_id = $1
`

func (q *Queries) DeletePost(ctx context.Context, postID int) error {
	_, err := q.db.Exec(ctx, deletePost, postID)
	return err
}

const getAllImagesByUserId = `-- name: GetAllImagesByUserId :many
SELECT images.image_id, images.post_id, images.height, images.width, images.image_blob_url, images.display_order
FROM images
JOIN posts ON images.post_id = posts.post_id
WHERE posts.user_id = $1
`

func (q *Queries) GetAllImagesByUserId(ctx context.Context, userID int) ([]Image, error) {
	rows, err := q.db.Query(ctx, getAllImagesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ImageID,
			&i.PostID,
			&i.Height,
			&i.Width,
			&i.ImageBlobUrl,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostIds = `-- name: GetAllPostIds :many
SELECT post_id
FROM posts
WHERE NOT EXISTS (
    SELECT 1
    FROM block
    WHERE block.user_id = $3 AND target_user_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM mute
    WHERE mute.user_id = $3 AND target_user_id = posts.user_id
)
ORDER BY posts.created_at DESC
LIMIT $1
OFFSET $2
`

type GetAllPostIdsParams struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
	UserID int `json:"userId"`
}

func (q *Queries) GetAllPostIds(ctx context.Context, arg GetAllPostIdsParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getAllPostIds, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostIdsCursor = `-- name: GetAllPostIdsCursor :many
SELECT post_id
FROM posts
WHERE NOT EXISTS (
    SELECT 1
    FROM block
    WHERE block.user_id = $3 AND target_user_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM mute
    WHERE mute.user_id = $3 AND target_user_id = posts.user_id
) AND (
    posts.visibilityType = 0 -- public
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $3
    )
) AND ($2::timestamp IS NULL OR posts.created_at < $2::timestamp)
ORDER BY posts.created_at DESC
LIMIT $1
`

type GetAllPostIdsCursorParams struct {
	Limit   int              `json:"limit"`
	Column2 pgtype.Timestamp `json:"column2"`
	UserID  int              `json:"userId"`
}

func (q *Queries) GetAllPostIdsCursor(ctx context.Context, arg GetAllPostIdsCursorParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getAllPostIdsCursor, arg.Limit, arg.Column2, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentCountByPostID = `-- name: GetCommentCountByPostID :one
SELECT COUNT(*)
FROM comments
WHERE post_id = $1
`

func (q *Queries) GetCommentCountByPostID(ctx context.Context, postID int) (int64, error) {
	row := q.db.QueryRow(ctx, getCommentCountByPostID, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getImagesByPostId = `-- name: GetImagesByPostId :many
SELECT image_id, post_id, height, width, image_blob_url, display_order
FROM images
WHERE images.post_id = $1
ORDER BY display_order ASC
`

func (q *Queries) GetImagesByPostId(ctx context.Context, postID int) ([]Image, error) {
	rows, err := q.db.Query(ctx, getImagesByPostId, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ImageID,
			&i.PostID,
			&i.Height,
			&i.Width,
			&i.ImageBlobUrl,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPinnedPostId = `-- name: GetPinnedPostId :one
SELECT pinned_post_id
FROM users
WHERE user_id = $1
`

func (q *Queries) GetPinnedPostId(ctx context.Context, userID int) (*int, error) {
	row := q.db.QueryRow(ctx, getPinnedPostId, userID)
	var pinned_post_id *int
	err := row.Scan(&pinned_post_id)
	return pinned_post_id, err
}

const getPollVotesGrouped = `-- name: GetPollVotesGrouped :many
SELECT option_index, COUNT(*) AS count
FROM poll_vote
WHERE post_id = $1
GROUP BY option_index
`

type GetPollVotesGroupedRow struct {
	OptionIndex int   `json:"optionIndex"`
	Count       int64 `json:"count"`
}

func (q *Queries) GetPollVotesGrouped(ctx context.Context, postID int) ([]GetPollVotesGroupedRow, error) {
	rows, err := q.db.Query(ctx, getPollVotesGrouped, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPollVotesGroupedRow
	for rows.Next() {
		var i GetPollVotesGroupedRow
		if err := rows.Scan(&i.OptionIndex, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT post_id, user_id, text, created_at, facets, attributes, visibilitytype
FROM posts
WHERE post_id = $1
AND (
    posts.visibilityType = 0 -- public
    OR posts.user_id = $2
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $2
    )
)
`

type GetPostByIdParams struct {
	PostID int `json:"postId"`
	UserID int `json:"userId"`
}

func (q *Queries) GetPostById(ctx context.Context, arg GetPostByIdParams) (Post, error) {
	row := q.db.QueryRow(ctx, getPostById, arg.PostID, arg.UserID)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.Facets,
		&i.Attributes,
		&i.Visibilitytype,
	)
	return i, err
}

const getPostIdsByFollowing = `-- name: GetPostIdsByFollowing :many
SELECT post_id
FROM posts
WHERE posts.user_id = $1 OR EXISTS (
  SELECT 1
  FROM follows
  WHERE follows.follower_id = $1 AND following_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM block
    WHERE user_id = $1 AND target_user_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM mute
    WHERE user_id = $1 AND target_user_id = posts.user_id
)
ORDER BY posts.created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostIdsByFollowingParams struct {
	UserID int `json:"userId"`
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

func (q *Queries) GetPostIdsByFollowing(ctx context.Context, arg GetPostIdsByFollowingParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getPostIdsByFollowing, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostIdsByFollowingCursor = `-- name: GetPostIdsByFollowingCursor :many
SELECT post_id
FROM posts
WHERE (posts.user_id = $1 OR EXISTS (
  SELECT 1
  FROM follows
  WHERE follows.follower_id = $1 AND following_id = posts.user_id
)) AND NOT EXISTS (
    SELECT 1
    FROM block
    WHERE user_id = $1 AND target_user_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM mute
    WHERE user_id = $1 AND target_user_id = posts.user_id
) AND (
    posts.visibilityType = 0 -- public
    OR posts.user_id = $1
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $1
    )
) AND ($3::timestamp IS NULL OR posts.created_at < $3::timestamp)
ORDER BY posts.created_at DESC
LIMIT $2
`

type GetPostIdsByFollowingCursorParams struct {
	UserID  int              `json:"userId"`
	Limit   int              `json:"limit"`
	Column3 pgtype.Timestamp `json:"column3"`
}

func (q *Queries) GetPostIdsByFollowingCursor(ctx context.Context, arg GetPostIdsByFollowingCursorParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getPostIdsByFollowingCursor, arg.UserID, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostIdsByUserIdCursor = `-- name: GetPostIdsByUserIdCursor :many
SELECT post_id
FROM posts
WHERE user_id = $1 AND ($3::timestamp IS NULL OR posts.created_at < $3::timestamp)
ORDER BY created_at DESC
LIMIT $2
`

type GetPostIdsByUserIdCursorParams struct {
	UserID  int              `json:"userId"`
	Limit   int              `json:"limit"`
	Column3 pgtype.Timestamp `json:"column3"`
}

func (q *Queries) GetPostIdsByUserIdCursor(ctx context.Context, arg GetPostIdsByUserIdCursorParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getPostIdsByUserIdCursor, arg.UserID, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostIdsForMutualFeed = `-- name: GetPostIdsForMutualFeed :many
WITH user_relationships AS (
  SELECT posts.post_id, posts.user_id,
    CASE
      WHEN posts.user_id = $1 THEN 'own'
      WHEN f.follower_id IS NOT NULL THEN 'friend'
      ELSE 'mutual'
    END as relationship_type
  FROM posts
  LEFT JOIN follows f ON f.follower_id = $1 AND f.following_id = posts.user_id
  WHERE (posts.user_id = $1 OR f.follower_id IS NOT NULL OR
         EXISTS (SELECT 1 FROM follows f1
                 INNER JOIN follows f2 ON f1.following_id = f2.follower_id
                 WHERE f1.follower_id = $1 AND f2.following_id = posts.user_id))
    AND NOT EXISTS (SELECT 1 FROM block WHERE user_id = $1 AND target_user_id = posts.user_id)
    AND NOT EXISTS (SELECT 1 FROM mute WHERE user_id = $1 AND target_user_id = posts.user_id)
)
SELECT post_id, user_id, relationship_type,
  CASE WHEN relationship_type = 'mutual' THEN
    (SELECT ARRAY_AGG(u.username) FROM follows f1
     INNER JOIN follows f2 ON f1.following_id = f2.follower_id
     INNER JOIN users u ON f2.follower_id = u.user_id
     WHERE f1.follower_id = $1 AND f2.following_id = user_relationships.user_id LIMIT 5)
  ELSE NULL END as mutual_usernames
FROM user_relationships
ORDER BY (SELECT created_at FROM posts WHERE posts.post_id = user_relationships.post_id) DESC
LIMIT $2 OFFSET $3
`

type GetPostIdsForMutualFeedParams struct {
	FollowerID int `json:"followerId"`
	Limit      int `json:"limit"`
	Offset     int `json:"offset"`
}

type GetPostIdsForMutualFeedRow struct {
	PostID           int         `json:"postId"`
	UserID           int         `json:"userId"`
	RelationshipType string      `json:"relationshipType"`
	MutualUsernames  interface{} `json:"mutualUsernames"`
}

func (q *Queries) GetPostIdsForMutualFeed(ctx context.Context, arg GetPostIdsForMutualFeedParams) ([]GetPostIdsForMutualFeedRow, error) {
	rows, err := q.db.Query(ctx, getPostIdsForMutualFeed, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostIdsForMutualFeedRow
	for rows.Next() {
		var i GetPostIdsForMutualFeedRow
		if err := rows.Scan(
			&i.PostID,
			&i.UserID,
			&i.RelationshipType,
			&i.MutualUsernames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostIdsForMutualFeedCursor = `-- name: GetPostIdsForMutualFeedCursor :many
WITH user_relationships AS (
  SELECT posts.post_id, posts.user_id,
    CASE
      WHEN posts.user_id = $1 THEN 'own'
      WHEN f.follower_id IS NOT NULL THEN 'friend'
      ELSE 'mutual'
    END as relationship_type
  FROM posts
  LEFT JOIN follows f ON f.follower_id = $1 AND f.following_id = posts.user_id
  WHERE (posts.user_id = $1 OR f.follower_id IS NOT NULL OR
         EXISTS (SELECT 1 FROM follows f1
                 INNER JOIN follows f2 ON f1.following_id = f2.follower_id
                 WHERE f1.follower_id = $1 AND f2.following_id = posts.user_id))
    AND NOT EXISTS (SELECT 1 FROM block WHERE user_id = $1 AND target_user_id = posts.user_id)
    AND NOT EXISTS (SELECT 1 FROM mute WHERE user_id = $1 AND target_user_id = posts.user_id)
    AND (
        posts.visibilityType = 0 -- public
        OR posts.user_id = $1
        OR EXISTS (
            SELECT 1
            FROM user_relationship
            WHERE user_id = posts.user_id
                AND target_user_id = $1
        )
    )
    AND ($3::timestamp IS NULL OR posts.created_at < $3::timestamp)
)
SELECT post_id, user_id, relationship_type,
  CASE WHEN relationship_type = 'mutual' THEN
    (SELECT ARRAY_AGG(u.username) FROM follows f1
     INNER JOIN follows f2 ON f1.following_id = f2.follower_id
     INNER JOIN users u ON f2.follower_id = u.user_id
     WHERE f1.follower_id = $1 AND f2.following_id = user_relationships.user_id LIMIT 5)
  ELSE NULL END as mutual_usernames
FROM user_relationships
ORDER BY (SELECT created_at FROM posts WHERE posts.post_id = user_relationships.post_id) DESC
LIMIT $2
`

type GetPostIdsForMutualFeedCursorParams struct {
	FollowerID int              `json:"followerId"`
	Limit      int              `json:"limit"`
	Column3    pgtype.Timestamp `json:"column3"`
}

type GetPostIdsForMutualFeedCursorRow struct {
	PostID           int         `json:"postId"`
	UserID           int         `json:"userId"`
	RelationshipType string      `json:"relationshipType"`
	MutualUsernames  interface{} `json:"mutualUsernames"`
}

func (q *Queries) GetPostIdsForMutualFeedCursor(ctx context.Context, arg GetPostIdsForMutualFeedCursorParams) ([]GetPostIdsForMutualFeedCursorRow, error) {
	rows, err := q.db.Query(ctx, getPostIdsForMutualFeedCursor, arg.FollowerID, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostIdsForMutualFeedCursorRow
	for rows.Next() {
		var i GetPostIdsForMutualFeedCursorRow
		if err := rows.Scan(
			&i.PostID,
			&i.UserID,
			&i.RelationshipType,
			&i.MutualUsernames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsIdsByUserId = `-- name: GetPostsIdsByUserId :many
SELECT post_id
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetPostsIdsByUserIdParams struct {
	UserID int `json:"userId"`
	Offset int `json:"offset"`
	Limit  int `json:"limit"`
}

func (q *Queries) GetPostsIdsByUserId(ctx context.Context, arg GetPostsIdsByUserIdParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getPostsIdsByUserId, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserVoteInPoll = `-- name: GetUserVoteInPoll :one
SELECT option_index
FROM poll_vote
WHERE post_id = $1 AND user_id = $2
`

type GetUserVoteInPollParams struct {
	PostID int `json:"postId"`
	UserID int `json:"userId"`
}

func (q *Queries) GetUserVoteInPoll(ctx context.Context, arg GetUserVoteInPollParams) (int, error) {
	row := q.db.QueryRow(ctx, getUserVoteInPoll, arg.PostID, arg.UserID)
	var option_index int
	err := row.Scan(&option_index)
	return option_index, err
}

const insertImage = `-- name: InsertImage :one
INSERT INTO images (post_id, height, width, image_blob_url, display_order)
VALUES ($1, $2, $3, $4, $5)
RETURNING image_id, post_id, height, width, image_blob_url, display_order
`

type InsertImageParams struct {
	PostID       int    `json:"postId"`
	Height       int    `json:"height"`
	Width        int    `json:"width"`
	ImageBlobUrl string `json:"imageBlobUrl"`
	DisplayOrder int    `json:"displayOrder"`
}

func (q *Queries) InsertImage(ctx context.Context, arg InsertImageParams) (Image, error) {
	row := q.db.QueryRow(ctx, insertImage,
		arg.PostID,
		arg.Height,
		arg.Width,
		arg.ImageBlobUrl,
		arg.DisplayOrder,
	)
	var i Image
	err := row.Scan(
		&i.ImageID,
		&i.PostID,
		&i.Height,
		&i.Width,
		&i.ImageBlobUrl,
		&i.DisplayOrder,
	)
	return i, err
}

const insertPost = `-- name: InsertPost :one
INSERT INTO posts (user_id, text, facets, attributes, visibilityType)
VALUES ($1, $2, $3, $4, $5)
RETURNING post_id, user_id, text, created_at, facets, attributes, visibilitytype
`

type InsertPostParams struct {
	UserID         int            `json:"userId"`
	Text           pgtype.Text    `json:"text"`
	Facets         db.Facets      `json:"facets"`
	Attributes     *db.Attributes `json:"attributes"`
	Visibilitytype int            `json:"visibilitytype"`
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (Post, error) {
	row := q.db.QueryRow(ctx, insertPost,
		arg.UserID,
		arg.Text,
		arg.Facets,
		arg.Attributes,
		arg.Visibilitytype,
	)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.Facets,
		&i.Attributes,
		&i.Visibilitytype,
	)
	return i, err
}

const insertVote = `-- name: InsertVote :exec
INSERT INTO poll_vote (post_id, user_id, option_index)
VALUES ($1, $2, $3) ON CONFLICT DO NOTHING
`

type InsertVoteParams struct {
	PostID      int `json:"postId"`
	UserID      int `json:"userId"`
	OptionIndex int `json:"optionIndex"`
}

func (q *Queries) InsertVote(ctx context.Context, arg InsertVoteParams) error {
	_, err := q.db.Exec(ctx, insertVote, arg.PostID, arg.UserID, arg.OptionIndex)
	return err
}

const pinPost = `-- name: PinPost :exec
UPDATE users
SET pinned_post_id = $2
WHERE user_id = $1
`

type PinPostParams struct {
	UserID       int  `json:"userId"`
	PinnedPostID *int `json:"pinnedPostId"`
}

func (q *Queries) PinPost(ctx context.Context, arg PinPostParams) error {
	_, err := q.db.Exec(ctx, pinPost, arg.UserID, arg.PinnedPostID)
	return err
}

const unpinPost = `-- name: UnpinPost :exec
UPDATE users
SET pinned_post_id = NULL
WHERE user_id = $1
`

func (q *Queries) UnpinPost(ctx context.Context, userID int) error {
	_, err := q.db.Exec(ctx, unpinPost, userID)
	return err
}

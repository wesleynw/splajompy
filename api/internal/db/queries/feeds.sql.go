// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feeds.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllPostIdsCursor = `-- name: GetAllPostIdsCursor :many
SELECT post_id
FROM posts
WHERE NOT EXISTS (
    SELECT 1
    FROM block
    WHERE block.user_id = $1::int AND target_user_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM mute
    WHERE mute.user_id = $1::int AND target_user_id = posts.user_id
) AND (
    posts.visibilityType = 0 -- public
    OR posts.user_id = $1::int
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $1::int
            AND user_relationship.created_at < posts.created_at
    )
) AND ($2::timestamp IS NULL OR posts.created_at < $2::timestamp)
ORDER BY posts.created_at DESC
LIMIT $3::int
`

type GetAllPostIdsCursorParams struct {
	UserID int              `json:"userId"`
	Before pgtype.Timestamp `json:"before"`
	Limit  int              `json:"limit"`
}

func (q *Queries) GetAllPostIdsCursor(ctx context.Context, arg GetAllPostIdsCursorParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getAllPostIdsCursor, arg.UserID, arg.Before, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT post_id, user_id, text, created_at, facets, attributes, visibilitytype
FROM posts
WHERE post_id = $1
AND (
    posts.visibilityType = 0 -- public
    OR posts.user_id = $2
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $2
            AND user_relationship.created_at < posts.created_at
    )
)
`

type GetPostByIdParams struct {
	PostID int `json:"postId"`
	UserID int `json:"userId"`
}

func (q *Queries) GetPostById(ctx context.Context, arg GetPostByIdParams) (Post, error) {
	row := q.db.QueryRow(ctx, getPostById, arg.PostID, arg.UserID)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.Facets,
		&i.Attributes,
		&i.Visibilitytype,
	)
	return i, err
}

const getPostIdsByFollowingCursor = `-- name: GetPostIdsByFollowingCursor :many
SELECT post_id
FROM posts
WHERE (posts.user_id = $1 OR EXISTS (
  SELECT 1
  FROM follows
  WHERE follows.follower_id = $1 AND following_id = posts.user_id
)) AND NOT EXISTS (
    SELECT 1
    FROM block
    WHERE user_id = $1 AND target_user_id = posts.user_id
) AND NOT EXISTS (
    SELECT 1
    FROM mute
    WHERE user_id = $1 AND target_user_id = posts.user_id
) AND (
    posts.visibilityType = 0 -- public
    OR posts.user_id = $1
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $1
            AND user_relationship.created_at < posts.created_at
    )
) AND ($3::timestamp IS NULL OR posts.created_at < $3::timestamp)
ORDER BY posts.created_at DESC
LIMIT $2
`

type GetPostIdsByFollowingCursorParams struct {
	UserID  int              `json:"userId"`
	Limit   int              `json:"limit"`
	Column3 pgtype.Timestamp `json:"column3"`
}

func (q *Queries) GetPostIdsByFollowingCursor(ctx context.Context, arg GetPostIdsByFollowingCursorParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getPostIdsByFollowingCursor, arg.UserID, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostIdsByUserIdCursor = `-- name: GetPostIdsByUserIdCursor :many
SELECT post_id
FROM posts
WHERE user_id = $1::int AND ($2::timestamp IS NULL OR posts.created_at < $2::timestamp)
AND (
    posts.visibilityType = 0 -- public
    OR posts.user_id = $3
    OR EXISTS (
        SELECT 1
        FROM user_relationship
        WHERE user_id = posts.user_id
            AND target_user_id = $3
            AND user_relationship.created_at < posts.created_at
    )
)
ORDER BY created_at DESC
LIMIT $4::int
`

type GetPostIdsByUserIdCursorParams struct {
	TargetUserID int              `json:"targetUserId"`
	Before       pgtype.Timestamp `json:"before"`
	UserID       int              `json:"userId"`
	Limit        int              `json:"limit"`
}

func (q *Queries) GetPostIdsByUserIdCursor(ctx context.Context, arg GetPostIdsByUserIdCursorParams) ([]int, error) {
	rows, err := q.db.Query(ctx, getPostIdsByUserIdCursor,
		arg.TargetUserID,
		arg.Before,
		arg.UserID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var post_id int
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostIdsForMutualFeedCursor = `-- name: GetPostIdsForMutualFeedCursor :many
WITH user_relationships AS (
  SELECT posts.post_id, posts.user_id,
    CASE
      WHEN posts.user_id = $1 THEN 'own'
      WHEN f.follower_id IS NOT NULL THEN 'friend'
      ELSE 'mutual'
    END as relationship_type
  FROM posts
  LEFT JOIN follows f ON f.follower_id = $1 AND f.following_id = posts.user_id
  WHERE (posts.user_id = $1 OR f.follower_id IS NOT NULL OR
         EXISTS (SELECT 1 FROM follows f1
                 INNER JOIN follows f2 ON f1.following_id = f2.follower_id
                 WHERE f1.follower_id = $1 AND f2.following_id = posts.user_id))
    AND NOT EXISTS (SELECT 1 FROM block WHERE user_id = $1 AND target_user_id = posts.user_id)
    AND NOT EXISTS (SELECT 1 FROM mute WHERE user_id = $1 AND target_user_id = posts.user_id)
    AND (
        posts.visibilityType = 0 -- public
        OR posts.user_id = $1
        OR EXISTS (
            SELECT 1
            FROM user_relationship
            WHERE user_id = posts.user_id
                AND target_user_id = $1
                AND user_relationship.created_at < posts.created_at
        )
    )
    AND ($3::timestamp IS NULL OR posts.created_at < $3::timestamp)
)
SELECT post_id, user_id, relationship_type,
  CASE WHEN relationship_type = 'mutual' THEN
    (SELECT ARRAY_AGG(u.username) FROM follows f1
     INNER JOIN follows f2 ON f1.following_id = f2.follower_id
     INNER JOIN users u ON f2.follower_id = u.user_id
     WHERE f1.follower_id = $1 AND f2.following_id = user_relationships.user_id LIMIT 5)
  ELSE NULL END as mutual_usernames
FROM user_relationships
ORDER BY (SELECT created_at FROM posts WHERE posts.post_id = user_relationships.post_id) DESC
LIMIT $2
`

type GetPostIdsForMutualFeedCursorParams struct {
	FollowerID int              `json:"followerId"`
	Limit      int              `json:"limit"`
	Column3    pgtype.Timestamp `json:"column3"`
}

type GetPostIdsForMutualFeedCursorRow struct {
	PostID           int         `json:"postId"`
	UserID           int         `json:"userId"`
	RelationshipType string      `json:"relationshipType"`
	MutualUsernames  interface{} `json:"mutualUsernames"`
}

func (q *Queries) GetPostIdsForMutualFeedCursor(ctx context.Context, arg GetPostIdsForMutualFeedCursorParams) ([]GetPostIdsForMutualFeedCursorRow, error) {
	rows, err := q.db.Query(ctx, getPostIdsForMutualFeedCursor, arg.FollowerID, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostIdsForMutualFeedCursorRow
	for rows.Next() {
		var i GetPostIdsForMutualFeedCursorRow
		if err := rows.Scan(
			&i.PostID,
			&i.UserID,
			&i.RelationshipType,
			&i.MutualUsernames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

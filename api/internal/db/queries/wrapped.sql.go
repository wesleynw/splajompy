// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wrapped.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	db "splajompy.com/api/v2/internal/db"
)

const getTotalCommentsForUser = `-- name: GetTotalCommentsForUser :one
SELECT COUNT(*)
FROM comments
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) GetTotalCommentsForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalCommentsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalLikesForUser = `-- name: GetTotalLikesForUser :one
SELECT COUNT(*)
FROM likes
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) GetTotalLikesForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalLikesForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNotificationsForUser = `-- name: GetTotalNotificationsForUser :one
SELECT COUNT(*)
FROM notifications
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) GetTotalNotificationsForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNotificationsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalPostsForUser = `-- name: GetTotalPostsForUser :one
SELECT COUNT(*)
FROM posts
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) GetTotalPostsForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalPostsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const wrappedDeleteAllStored = `-- name: WrappedDeleteAllStored :exec
DELETE FROM wrapped
`

func (q *Queries) WrappedDeleteAllStored(ctx context.Context) error {
	_, err := q.db.Exec(ctx, wrappedDeleteAllStored)
	return err
}

const wrappedGetAllUserCommentsWithCursor = `-- name: WrappedGetAllUserCommentsWithCursor :many
SELECT comment_id, post_id, user_id, text, facets, created_at
FROM comments
WHERE user_id = $1
  AND EXTRACT(YEAR FROM created_at) = 2025
  AND ($3::timestamp IS NULL OR created_at < $3)
ORDER BY created_at DESC
LIMIT $2
`

type WrappedGetAllUserCommentsWithCursorParams struct {
	UserID int              `json:"userId"`
	Limit  int              `json:"limit"`
	Cursor pgtype.Timestamp `json:"cursor"`
}

func (q *Queries) WrappedGetAllUserCommentsWithCursor(ctx context.Context, arg WrappedGetAllUserCommentsWithCursorParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserCommentsWithCursor, arg.UserID, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.PostID,
			&i.UserID,
			&i.Text,
			&i.Facets,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetAllUserIds = `-- name: WrappedGetAllUserIds :many
SELECT user_id
FROM users
`

func (q *Queries) WrappedGetAllUserIds(ctx context.Context) ([]int, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var user_id int
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetAllUserLikesWithCursor = `-- name: WrappedGetAllUserLikesWithCursor :many
SELECT post_id, comment_id, user_id, created_at
FROM likes
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
    AND ($3::timestamptz IS NULL OR created_at < $3::timestamptz)
ORDER BY created_at DESC
LIMIT $2
`

type WrappedGetAllUserLikesWithCursorParams struct {
	UserID int                `json:"userId"`
	Limit  int                `json:"limit"`
	Cursor pgtype.Timestamptz `json:"cursor"`
}

func (q *Queries) WrappedGetAllUserLikesWithCursor(ctx context.Context, arg WrappedGetAllUserLikesWithCursorParams) ([]Like, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserLikesWithCursor, arg.UserID, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Like
	for rows.Next() {
		var i Like
		if err := rows.Scan(
			&i.PostID,
			&i.CommentID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetAllUserPostsWithCursor = `-- name: WrappedGetAllUserPostsWithCursor :many
SELECT post_id, user_id, text, created_at, facets, attributes
FROM posts
WHERE user_id = $1
  AND EXTRACT(YEAR FROM created_at) = 2025
  AND ($3::timestamp IS NULL OR created_at < $3::timestamp)
ORDER BY created_at DESC
LIMIT $2
`

type WrappedGetAllUserPostsWithCursorParams struct {
	UserID int              `json:"userId"`
	Limit  int              `json:"limit"`
	Cursor pgtype.Timestamp `json:"cursor"`
}

func (q *Queries) WrappedGetAllUserPostsWithCursor(ctx context.Context, arg WrappedGetAllUserPostsWithCursorParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserPostsWithCursor, arg.UserID, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.UserID,
			&i.Text,
			&i.CreatedAt,
			&i.Facets,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetAverageImageCountPerPost = `-- name: WrappedGetAverageImageCountPerPost :one
SELECT AVG(image_count)
FROM (
    SELECT COUNT(*) as image_count
    FROM images
    JOIN posts ON images.post_id = posts.post_id
    WHERE EXTRACT(YEAR FROM created_at) = 2025
    GROUP BY images.post_id
) subquery
`

func (q *Queries) WrappedGetAverageImageCountPerPost(ctx context.Context) (float64, error) {
	row := q.db.QueryRow(ctx, wrappedGetAverageImageCountPerPost)
	var avg float64
	err := row.Scan(&avg)
	return avg, err
}

const wrappedGetAverageImageCountPerPostForUser = `-- name: WrappedGetAverageImageCountPerPostForUser :one
SELECT COALESCE(AVG(image_count), 0)::int
FROM (
    SELECT COUNT(*) as image_count
    FROM images
    JOIN posts ON images.post_id = posts.post_id
    WHERE posts.user_id = $1 AND EXTRACT(YEAR FROM posts.created_at) = 2025
    GROUP BY images.post_id
) subquery
`

func (q *Queries) WrappedGetAverageImageCountPerPostForUser(ctx context.Context, userID int) (int, error) {
	row := q.db.QueryRow(ctx, wrappedGetAverageImageCountPerPostForUser, userID)
	var column_1 int
	err := row.Scan(&column_1)
	return column_1, err
}

const wrappedGetAveragePostLength = `-- name: WrappedGetAveragePostLength :one
SELECT avg(length(text))
FROM posts
WHERE EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) WrappedGetAveragePostLength(ctx context.Context) (float64, error) {
	row := q.db.QueryRow(ctx, wrappedGetAveragePostLength)
	var avg float64
	err := row.Scan(&avg)
	return avg, err
}

const wrappedGetAveragePostLengthForUser = `-- name: WrappedGetAveragePostLengthForUser :one
SELECT avg(length(text))
FROM posts
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) WrappedGetAveragePostLengthForUser(ctx context.Context, userID int) (float64, error) {
	row := q.db.QueryRow(ctx, wrappedGetAveragePostLengthForUser, userID)
	var avg float64
	err := row.Scan(&avg)
	return avg, err
}

const wrappedGetCommentCountForUser = `-- name: WrappedGetCommentCountForUser :one
SELECT COUNT(*)
FROM comments
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) WrappedGetCommentCountForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, wrappedGetCommentCountForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const wrappedGetCompiledDataByUserId = `-- name: WrappedGetCompiledDataByUserId :one
SELECT content, generated
FROM wrapped
WHERE user_id = $1
`

type WrappedGetCompiledDataByUserIdRow struct {
	Content   []byte           `json:"content"`
	Generated pgtype.Timestamp `json:"generated"`
}

func (q *Queries) WrappedGetCompiledDataByUserId(ctx context.Context, userID int) (WrappedGetCompiledDataByUserIdRow, error) {
	row := q.db.QueryRow(ctx, wrappedGetCompiledDataByUserId, userID)
	var i WrappedGetCompiledDataByUserIdRow
	err := row.Scan(&i.Content, &i.Generated)
	return i, err
}

const wrappedGetMostLikedPostId = `-- name: WrappedGetMostLikedPostId :one
SELECT likes.post_id, COUNT(*)
FROM likes
JOIN posts ON likes.post_id = posts.post_id
WHERE posts.user_id = $1 AND comment_id IS NULL
    AND EXTRACT(YEAR FROM likes.created_at) = 2025
GROUP BY likes.post_id
ORDER BY COUNT(*) DESC
`

type WrappedGetMostLikedPostIdRow struct {
	PostID int   `json:"postId"`
	Count  int64 `json:"count"`
}

func (q *Queries) WrappedGetMostLikedPostId(ctx context.Context, userID int) (WrappedGetMostLikedPostIdRow, error) {
	row := q.db.QueryRow(ctx, wrappedGetMostLikedPostId, userID)
	var i WrappedGetMostLikedPostIdRow
	err := row.Scan(&i.PostID, &i.Count)
	return i, err
}

const wrappedGetPollsThatUserVotedIn = `-- name: WrappedGetPollsThatUserVotedIn :many
SELECT posts.post_id, posts.user_id, text, posts.created_at, facets, attributes, id, poll_vote.post_id, poll_vote.user_id, option_index, poll_vote.created_at
FROM posts
JOIN poll_vote ON posts.post_id = poll_vote.post_id
WHERE attributes->'poll' IS NOT NULL AND poll_vote.user_id = $1
`

type WrappedGetPollsThatUserVotedInRow struct {
	PostID      int              `json:"postId"`
	UserID      int              `json:"userId"`
	Text        pgtype.Text      `json:"text"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	Facets      db.Facets        `json:"facets"`
	Attributes  *db.Attributes   `json:"attributes"`
	ID          int              `json:"id"`
	PostID_2    int              `json:"postId2"`
	UserID_2    int              `json:"userId2"`
	OptionIndex int              `json:"optionIndex"`
	CreatedAt_2 pgtype.Timestamp `json:"createdAt2"`
}

func (q *Queries) WrappedGetPollsThatUserVotedIn(ctx context.Context, userID int) ([]WrappedGetPollsThatUserVotedInRow, error) {
	rows, err := q.db.Query(ctx, wrappedGetPollsThatUserVotedIn, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WrappedGetPollsThatUserVotedInRow
	for rows.Next() {
		var i WrappedGetPollsThatUserVotedInRow
		if err := rows.Scan(
			&i.PostID,
			&i.UserID,
			&i.Text,
			&i.CreatedAt,
			&i.Facets,
			&i.Attributes,
			&i.ID,
			&i.PostID_2,
			&i.UserID_2,
			&i.OptionIndex,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetPostCountForUser = `-- name: WrappedGetPostCountForUser :one
SELECT COUNT(*)
FROM posts
WHERE user_id = $1 AND EXTRACT(YEAR FROM created_at) = 2025
`

func (q *Queries) WrappedGetPostCountForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, wrappedGetPostCountForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const wrappedGetUsersWhoGetMostComments = `-- name: WrappedGetUsersWhoGetMostComments :many
SELECT
    u.user_id,
    COUNT(*) as comment_count
FROM comments c
JOIN posts p ON c.post_id = p.post_id
JOIN users u ON p.user_id = u.user_id
WHERE c.user_id = $1 AND p.user_id != $1
    AND EXTRACT(YEAR FROM c.created_at) = 2025
GROUP BY u.user_id, u.username
ORDER BY comment_count DESC
`

type WrappedGetUsersWhoGetMostCommentsRow struct {
	UserID       int   `json:"userId"`
	CommentCount int64 `json:"commentCount"`
}

func (q *Queries) WrappedGetUsersWhoGetMostComments(ctx context.Context, userID int) ([]WrappedGetUsersWhoGetMostCommentsRow, error) {
	rows, err := q.db.Query(ctx, wrappedGetUsersWhoGetMostComments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WrappedGetUsersWhoGetMostCommentsRow
	for rows.Next() {
		var i WrappedGetUsersWhoGetMostCommentsRow
		if err := rows.Scan(&i.UserID, &i.CommentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetUsersWhoGetMostLikesForComments = `-- name: WrappedGetUsersWhoGetMostLikesForComments :many
SELECT
    u.user_id,
    COUNT(*) as like_count
FROM likes l
JOIN comments c ON l.comment_id = c.comment_id
JOIN users u ON c.user_id = u.user_id
WHERE l.user_id = $1 AND l.comment_id IS NOT NULL
    AND EXTRACT(YEAR FROM l.created_at) = 2025
GROUP BY u.user_id, u.username
ORDER BY like_count DESC
`

type WrappedGetUsersWhoGetMostLikesForCommentsRow struct {
	UserID    int   `json:"userId"`
	LikeCount int64 `json:"likeCount"`
}

func (q *Queries) WrappedGetUsersWhoGetMostLikesForComments(ctx context.Context, userID int) ([]WrappedGetUsersWhoGetMostLikesForCommentsRow, error) {
	rows, err := q.db.Query(ctx, wrappedGetUsersWhoGetMostLikesForComments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WrappedGetUsersWhoGetMostLikesForCommentsRow
	for rows.Next() {
		var i WrappedGetUsersWhoGetMostLikesForCommentsRow
		if err := rows.Scan(&i.UserID, &i.LikeCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetUsersWhoGetMostLikesForPosts = `-- name: WrappedGetUsersWhoGetMostLikesForPosts :many
SELECT
    u.user_id,
    COUNT(*) as like_count
FROM likes l
JOIN posts p ON l.post_id = p.post_id
JOIN users u ON p.user_id = u.user_id
WHERE l.user_id = $1 AND l.comment_id IS NULL
    AND EXTRACT(YEAR FROM l.created_at) = 2025
GROUP BY u.user_id, u.username
ORDER BY like_count DESC
`

type WrappedGetUsersWhoGetMostLikesForPostsRow struct {
	UserID    int   `json:"userId"`
	LikeCount int64 `json:"likeCount"`
}

func (q *Queries) WrappedGetUsersWhoGetMostLikesForPosts(ctx context.Context, userID int) ([]WrappedGetUsersWhoGetMostLikesForPostsRow, error) {
	rows, err := q.db.Query(ctx, wrappedGetUsersWhoGetMostLikesForPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WrappedGetUsersWhoGetMostLikesForPostsRow
	for rows.Next() {
		var i WrappedGetUsersWhoGetMostLikesForPostsRow
		if err := rows.Scan(&i.UserID, &i.LikeCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedUpdateCompiledDataByUserId = `-- name: WrappedUpdateCompiledDataByUserId :exec
INSERT INTO wrapped (user_id, content)
VALUES ($1, $2)
ON CONFLICT (user_id)
DO UPDATE SET content = $2
`

type WrappedUpdateCompiledDataByUserIdParams struct {
	UserID  int    `json:"userId"`
	Content []byte `json:"content"`
}

func (q *Queries) WrappedUpdateCompiledDataByUserId(ctx context.Context, arg WrappedUpdateCompiledDataByUserIdParams) error {
	_, err := q.db.Exec(ctx, wrappedUpdateCompiledDataByUserId, arg.UserID, arg.Content)
	return err
}

const wrappedUserHasOneLike = `-- name: WrappedUserHasOneLike :one
SELECT EXISTS (
    SELECT 1
    FROM likes
    JOIN posts ON likes.post_id = posts.post_id
    WHERE likes.comment_id IS NULL
    AND posts.user_id = $1
        AND EXTRACT(YEAR FROM likes.created_at) = 2025
        AND EXTRACT(YEAR FROM posts.created_at) = 2025
)
`

func (q *Queries) WrappedUserHasOneLike(ctx context.Context, userID int) (bool, error) {
	row := q.db.QueryRow(ctx, wrappedUserHasOneLike, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const wrappedUserHasPost = `-- name: WrappedUserHasPost :one
SELECT EXISTS (
    SELECT 1
    FROM posts
    WHERE user_id = $1
        AND EXTRACT(YEAR FROM posts.created_at) = 2025
)
`

func (q *Queries) WrappedUserHasPost(ctx context.Context, userID int) (bool, error) {
	row := q.db.QueryRow(ctx, wrappedUserHasPost, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wrapped.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTotalCommentsForUser = `-- name: GetTotalCommentsForUser :one
SELECT COUNT(*)
FROM comments
WHERE user_id = $1
`

func (q *Queries) GetTotalCommentsForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalCommentsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalLikesForUser = `-- name: GetTotalLikesForUser :one
SELECT COUNT(*)
FROM likes
WHERE user_id = $1
`

func (q *Queries) GetTotalLikesForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalLikesForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNotificationsForUser = `-- name: GetTotalNotificationsForUser :one
SELECT COUNT(*)
FROM notifications
WHERE user_id = $1
`

func (q *Queries) GetTotalNotificationsForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNotificationsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalPostsForUser = `-- name: GetTotalPostsForUser :one
SELECT COUNT(*)
FROM posts
WHERE user_id = $1
`

func (q *Queries) GetTotalPostsForUser(ctx context.Context, userID int) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalPostsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const wrappedGetAllUserCommentsWithCursor = `-- name: WrappedGetAllUserCommentsWithCursor :many
SELECT comment_id, post_id, user_id, text, facets, created_at
FROM comments
WHERE user_id = $1 AND ($3::timestamp IS NULL OR created_at < $3)
ORDER BY created_at DESC
LIMIT $2
`

type WrappedGetAllUserCommentsWithCursorParams struct {
	UserID int              `json:"userId"`
	Limit  int              `json:"limit"`
	Cursor pgtype.Timestamp `json:"cursor"`
}

func (q *Queries) WrappedGetAllUserCommentsWithCursor(ctx context.Context, arg WrappedGetAllUserCommentsWithCursorParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserCommentsWithCursor, arg.UserID, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.PostID,
			&i.UserID,
			&i.Text,
			&i.Facets,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetAllUserLikesWithCursor = `-- name: WrappedGetAllUserLikesWithCursor :many
SELECT post_id, comment_id, user_id, created_at
FROM likes
WHERE user_id = $1 AND ($3::timestamptz IS NULL OR created_at < $3::timestamptz)
ORDER BY created_at DESC
LIMIT $2
`

type WrappedGetAllUserLikesWithCursorParams struct {
	UserID int                `json:"userId"`
	Limit  int                `json:"limit"`
	Cursor pgtype.Timestamptz `json:"cursor"`
}

func (q *Queries) WrappedGetAllUserLikesWithCursor(ctx context.Context, arg WrappedGetAllUserLikesWithCursorParams) ([]Like, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserLikesWithCursor, arg.UserID, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Like
	for rows.Next() {
		var i Like
		if err := rows.Scan(
			&i.PostID,
			&i.CommentID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wrappedGetAllUserPostsWithCursor = `-- name: WrappedGetAllUserPostsWithCursor :many
SELECT post_id, user_id, text, created_at, facets, attributes
FROM posts
WHERE user_id = $1 AND ($3::timestamp IS NULL OR created_at < $3::timestamp)
ORDER BY created_at DESC
LIMIT $2
`

type WrappedGetAllUserPostsWithCursorParams struct {
	UserID int              `json:"userId"`
	Limit  int              `json:"limit"`
	Cursor pgtype.Timestamp `json:"cursor"`
}

func (q *Queries) WrappedGetAllUserPostsWithCursor(ctx context.Context, arg WrappedGetAllUserPostsWithCursorParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, wrappedGetAllUserPostsWithCursor, arg.UserID, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.UserID,
			&i.Text,
			&i.CreatedAt,
			&i.Facets,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
